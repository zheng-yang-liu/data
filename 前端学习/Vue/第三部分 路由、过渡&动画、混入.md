# 第三部分 路由、过渡&动画、混入

## 一、路由

### 一）路由的原理

Vue 路由是 Vue.js 框架中的一部分，用于帮助开发者构建单页应用（single page web application，SPA）。路由器是一个插件，可以管理不同视图之间的导航。

Vue 路由的基本原理是将 URL 映射到 Vue 组件。路由器可以配置多个路由规则，每个规则映射到一个组件。当用户在浏览器中输入 URL 或单击页面中的链接时，路由器会根据 URL 匹配路由规则并加载相应的组件。

Vue.js 路由需要载入 vue-router 库。

### 二）安装VUE路由库

下载地址：

```
https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js
```

### 三）应用路由

示例

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 路由应用示例</title>
<script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"></script>
<script src="https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js"></script>
</head>
<body>
<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo" >Go to Foo</router-link>
    <router-link to="/bar">Go to Bar</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>

<script>
// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)

// 1. 定义（路由）组件。
// 可以从其他文件 import 进来
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中"component" 可以是
// 通过 Vue.extend() 创建的组件构造器，
// 或者，只是一个组件配置对象。
// 我们晚点再讨论嵌套路由。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]

// 3. 创建 router 实例，然后传 `routes` 配置
// 你还可以传别的配置参数, 不过先这么简单着吧。
const router = new VueRouter({
  routes // （缩写）相当于 routes: routes
})

// 4. 创建和挂载根实例。
// 记得要通过 router 配置参数注入路由，
// 从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount('#app')

// 现在，应用已经启动了！
</script>
</body>
</html>
```

#### 1、应用路由步骤

1）定义（路由）组件。

2）定义路由。

3）创建 router 实例，传 `routes` 配置。

4）创建和挂载根实例。

5）网页模板中的代码

#### 2、语法说明

< router-link to="/foo">Go to Foo< /router-link>

router-link会被渲染成一个< a>标签。

to属性就是指向某个具体的链接，链接的内容会被渲染到router-view标签中。一般为带有#的一个路径。

```
<!-- 字符串 -->
<router-link to="home">Home</router-link>
<!-- 渲染结果 -->
<a href="home">Home</a>
<!-- 使用 v-bind 的 JS 表达式 -->
<router-link v-bind:to="'home'">Home</router-link>
<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->
<router-link :to="'home'">Home</router-link>
<!-- 同上 -->
<router-link :to="{ path: 'home' }">Home</router-link>
<!-- 命名的路由 -->
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
<!-- 带查询参数，下面的结果为 /register?plan=private -->
<router-link :to="{ path: 'register', query: { plan: 'private' }}">Register</router-link>
```

< router-view>< /router-view>  某个路由地址被访问后而显示的内容。

被点击过的路由（当前路由）会添加“router-link-exact-active router-link-active”样式属性。

### replace

设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录。

```
<router-link :to="{ path: '/abc'}" replace></router-link>
```

### append

设置 append 属性后，则在当前 (相对) 路径前添加其路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b

```
<router-link :to="{ path: 'relative/path'}" append></router-link>
```

### tag

有时候想要 `<router-link>` 渲染成某种标签，例如 `<li>`。 于是我们使用 `tag` prop 类指定何种标签，同样它还是会监听点击，触发导航。

```
<router-link to="/foo" tag="li">foo</router-link>
<!-- 渲染结果 -->
<li>foo</li>
```

### active-class

设置 链接激活时使用的 CSS 类名。可以通过以下代码来替代。

```
<style>
   ._active{
      background-color : red;
   }
</style>
<p>
   <router-link v-bind:to = "{ path: '/route1'}" active-class = "_active">Router Link 1</router-link>
   <router-link v-bind:to = "{ path: '/route2'}" tag = "span">Router Link 2</router-link>
</p>
```

注意这里 **class** 使用 **active-class="_active"**。

### exact-active-class

配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代。

```
<p>
   <router-link v-bind:to = "{ path: '/route1'}" exact-active-class = "_active">Router Link 1</router-link>
   <router-link v-bind:to = "{ path: '/route2'}" tag = "span">Router Link 2</router-link>
</p>
```

```
exact-active-class 和 active-class 的区别

router-link 默认情况下的路由是模糊匹配，例如当前路径是 /article/1 那么也会激活 ，所以当设置 exact-active-class 以后，这个 router-link 只有在当前路由被全包含匹配时才会被激活 exact-active-class 中的 class
```

### event

声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。

```
<router-link v-bind:to = "{ path: '/route1'}" event = "mouseover">Router Link 1</router-link>
```

以上代码设置了 event 为 mouseover ，及在鼠标移动到 Router Link 1 上时导航的 HTML 内容会发生改变。

## 二、过渡&动画

### 一）过渡

#### 1、Vue应用

Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括：

- 在 **CSS** 过渡和动画中自动应用 **class**
- 可以配合使用第三方 **CSS** 动画库，如 **Animate.css**
- 在过渡钩子函数中使用 **JavaScript** 直接操作 **DOM**
- 可以配合使用第三方 **JavaScript** 动画库，如 **Velocity.js**

#### 2、语法 

```
<transition name = "nameoftransition">
   <div></div>
</transition>
```

#### 3、示例

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 过渡示例</title>
<script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>
<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}
</style>
</head>
<body>
<div id="app">
  <button @click="show = !show">
    Toggle
  </button>
  <transition name="fade">
    <p v-if="show">hello</p>
  </transition>
</div>
<script type = "text/javascript">
new Vue({
  el: '#app',
  data: {
    show: true
  }
});
</script>
</body>
</html>
```

#### 4、执行过程

当插入或删除包含在 **transition** 组件中的元素时，**Vue** 将会做以下处理：

1. 自动嗅探目标元素是否应用了 **CSS** 过渡或动画，如果是，在恰当的时机添加/删除 **CSS** 类名
2. 如果过渡组件提供了 **JavaScript** 钩子函数，这些钩子函数将在恰当的时机被调用
3. 如果没有找到 **JavaScript** 钩子并且也没有检测到 **CSS** 过渡/动画，**DOM** 操作 (插入/删除) 在下一帧中立即执行（这里是指浏览器逐帧动画机制，和 **Vue** 的 **nextTick** 概念不同）

#### 5、过渡的类名

过渡其实就是一个淡入淡出的效果。Vue在元素显示与隐藏的过渡中，提供了 6 个 class 来切换：

1. **v-enter**：定义进入过渡的开始状态，在元素被插入之前生效，在元素被插入之后的下一帧移除
2. **v-enter-active**：定义进入过渡生效时的状态，在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡 / 动画完成之后移除；这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数
3. **v-enter-to**：2.1.8 版及以上定义进入过渡的结束状态，在元素被插入之后下一帧生效 (与此同时 **v-enter** 被移除)，在过渡 / 动画完成之后移除
4. **v-leave**：定义离开过渡的开始状态，在离开过渡被触发时立刻生效，下一帧被移除
5. **v-leave-active**：定义离开过渡生效时的状态，在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡 / 动画完成之后移除；这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数
6. **v-leave-to**：2.1.8 版及以上定义离开过渡的结束状态，在离开过渡被触发之后下一帧生效 (与此同时 **v-leave** 被删除)，在过渡/动画完成之后移除。

![](vue-3.png)

对于这些在过渡中切换的类名来说，如果使用一个没有名字的 < transition>，则 v- 是这些类名的默认前缀；如使用了 < transition name="my-transition">，那么 v-enter会替换为 my-transition-enter。

### 二）CSS过渡

常用的过渡都是使用 **CSS** 过渡，下面是个例子：

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 过渡示例</title>
<script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>
<style>
/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateX(10px);
  opacity: 0;
}
</style>
</head>
<body>
<div id="app">
  <button @click="show = !show">
    Toggle render
  </button>
  <transition name="slide-fade">
    <p v-if="show">hello</p>
  </transition>
</div>
<script type = "text/javascript">
new Vue({
  el: '#app',
  data: {
    show: true
  }
});
</script>
</body>
</html>
```

### 三）CSS 动画

**CSS** 动画用法和 **CSS** 过渡类似，区别是在动画中 **v-enter** 类名在节点插入 **DOM** 后不会立即删除，而是在 **animationend** 事件触发时删除，下面是个例子：

## 三、混入

